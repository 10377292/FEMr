% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mesh.2D.R
\name{refine.MESH.2D}
\alias{refine.MESH.2D}
\title{Refine a triangular mesh}
\usage{
refine.MESH.2D(mesh, minimum_angle, maximum_area, delaunay, verbosity)
}
\arguments{
\item{mesh}{An object of the class TRIMESH2D created by \link{create.MESH.2D}.}

\item{minimum_angle}{A condition on the minimum angle that mesh triangles must satisfy.}

\item{maximum_area}{A condition on the maximum area that mesh triangles  must satisfy.}

\item{delaunay}{A boolean parameter indicating whether or not the output mesh should satisfy the Delaunay condition.}

\item{verbosity}{This can be '0', '1' or '2'. It indicates the level of verbosity in triangulation process.}
}
\value{
@return An object of the class TRIMESH2D with the following variables:
\item{\code{nodes}}{A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.}
\item{\code{nodesmarkers}}{A #nodes-vector with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.}
\item{\code{nodesattributes}}{A #nodes-by-n1 matrix containg nodes' attributes. 
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed  
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value 
of a Dirichlet boundary conditions at boundary nodes added during the triangulation process.}
\item{\code{triangles}}{A #triangles-by-3 (when \code{order} = 1) or #triangles-by-6 matrix (when \code{order} = 2).
It specify the triangles giving the indices in \code{nodes} of the triangles' vertices and  the triangle edges midpoints (when \code{nodes} = 2). The triangles' vertices and middle points are ordered as descrcibed 
at  https://www.cs.cmu.edu/~quake/triangle.highorder.html.}
\item{\code{segments}}{A #segments-by-2 matrix. Each row contains the indices (starting from zero) of the nodes where the segment starts from and ends to.
Segments are edges that are not splitted during the triangulation process. }
\item{\code{segmentsmarker}}{A #segments-vector with entries either '1' or '0'. An entry '1' indicates that the corresponding segment is a boundary segment;  
an entry '0' indicates that the corresponding segment is not a boundary segment.}
\item{\code{edges}}{A #edges-by-2 matrix. . Each row contains the indices (starting from zero) of the nodes where the edge starts from and ends to.}
\item{\code{edgesmarkers}}{A #edges-vector with entries either '1' or '0'. An entry '1' indicates that the corresponding edge is a boundary edge;  
an entry '0' indicates that the corresponding edge is not a boundary edge.}
\item{\code{neighbors}}{A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. An entry '-1' indicates that 
one side of the triangle is aboundary edge.}
\item{\code{holes}}{A #holes-by-2 matrix containg a point internal to each hole of the mesh. These points are used to carve the holes
after the triangulation procedure.}
\item{\code{order}}{Either '1' or '2'. It specifies wether each mesh triangle is represented by a 3 nodes (the triangle' vertices) or 6 nodes (the triangle'svertices and midpoints). 
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements.}
}
\description{
This function refine a Constrained Delaunay triangulation into a Conforming Delaunay triangulation. This is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). It can be used to 
refine a mesh created previously with \link{create.MESH.2D}. The algorithm can add Steiner points (points through which the \code{segments} are splitted)
in order to meet the imposed conditions.
}
\examples{
## Upload the Meuse data and a domain boundary for these data
data(MeuseData)
data(MeuseBorder)
## Create a Constrained Delaunay triangulation
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
## Plot the mesh
plot(mesh)
## Refine the triangulation
mesh_refine <- refine.MESH.2D(mesh, minimum_angle = 30, maximum_area = 10000)
plot(mesh_refine)
}

