% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/mesh.2D.R
\name{refine.MESH.2D}
\alias{refine.MESH.2D}
\title{Refine a Constrained Delaunay triangulation to a Conforming Delaunay triangulation}
\usage{
refine.MESH.2D(mesh, minimum_angle, maximum_area, delaunay, verbosity)
}
\arguments{
\item{mesh}{An object of the class TRIMESH2D constructed through the function \code{create.MESH.2D}}

\item{minimum_angle}{A condition on the minimum angle that each vertex of each triangle of the output mesh should respect.}

\item{maximum_area}{A condition on the maximum area that each traingle should respect.}

\item{delaunay}{A boolean parameter indicating whether or not the output mesh should respect the Delaunay condition.}

\item{verbosity}{This can be '0', '1' or '2'. It indicates the level of verbosity in triangulation process.}
}
\value{
An object of the class TRIMESH with the following variables:
 \item{\code{nodes}}{A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.}
 \item{\code{nodesmarkers}}{A #nodes-vector containing '1' and '0' to indicate whether or not the node is a boundary node.}
 \item{\code{nodesattributes}}{A #nodes-by-n1 matrix containg some attributes for each point.
       These are copied unchanged to the output mesh for points in \code{nodes}. However for new points introducted by triangulation
       procedure or further refinements, each new point added to the mesh will have quantities assigned to it by linear interpolation. This option is commonly
       used to spread the Boundary Conditions to the new nodes introduced by the triangulation process.}
 \item{\code{triangles}}{A #triangles-by-3 or #triangles-by-6 matrix, respectively where a 1st and 2nd order mesh is created. In https://www.cs.cmu.edu/~quake/triangle.highorder.html
a picture of the node ordering can be found.}
 \item{\code{segments}}{A #segments-by-2 matrix. Each row contains the indices (starting from zero) of the point where a segments start from and finisces to.
       Segments are edges that persist after the triangulation. In he basic usage of the library segments are used to define the boundary
       of the domain.}
 \item{\code{segmentsmarker}}{A #segments-vector containing '1' and '0' to indicate whether or not the segment is a boundary segment.}
 \item{\code{edges}}{A #edges-by-2 matrix. Each row contains the indices (starting from zero) of the point where an edge start from and finisces to.}
 \item{\code{edgesmarkers}}{A #edges-vector containing '1' and '0' to indicate whether or not the segment is a boundary edge.}
 \item{\code{neighbors}}{A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. '-1' if
 one side of the triangle is an edge on the boundary of the mesh.}
 \item{\code{holes}}{A #holes-by-2 matrix containg a point internal to each hole of the mesh. These points are used to carve the holes
       after the triangulation procedure.}

 \item{\code{order}}{This can be '1' or '2'. It specifies if the triangular output elements is represented by a 3 or 6 nodes.}
}
\description{
This function is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). It can be used to
refine a mesh created previously with \link{create.MESH.2D}. The algorithm can add Steiner points (points through which the \code{segments} are splitted)
in order to meet the imposed conditions.
}
\examples{
library(FEMr)

data(MeuseData)
data(MeuseBorder)
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
plot(mesh)

mesh_refine <- refine.MESH.2D(mesh, minimum_angle = 30, maximum_area = 10000)
plot(mesh_refine)
}

