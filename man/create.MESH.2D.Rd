% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/mesh.2D.R
\name{create.MESH.2D}
\alias{create.MESH.2D}
\title{Create a Constrained Delaunay triangulation}
\usage{
create.MESH.2D(nodes = nodeslist, segments = segmentlist)
}
\arguments{
\item{nodes}{A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes}

\item{nodesmarkers}{A #nodes-vector containing '1' and '0' to indicate whether or not the node is a boundary node}

\item{nodesattributes}{A #nodes-by-n1 matrix containg some attributes to each point.
These are copied unchanged to the output mesh for points in \code{nodes}. However for new points introducted by triangulation
procedure or further refinements, each new point added to the mesh will have quantities assigned to it by linear interpolation. This option is commonly
used to spread the Boundary Conditions to the new nodes introduced by the triangulation process}

\item{segments}{A #segments-by-2 matrix. Each row contains the indices (starting from zero) of the point where a segments start from and finisces to.
Segments are edges that persist after the triangulation. In he basic usage of the library segments are used to define the boundary
of the domain.}

\item{segmentsmarkers}{A #segments-vector containing '1' and '0' to indicate whether or not the segment is a boundary segment.}

\item{holes}{A #holes-by-2 matrix containg a point internal to each hole of the mesh. These points are used to carve the holes
after the triangulation procedure.}

\item{triangles}{A #triangles-by-3 or #triangles-by-6 matrix. This defines the triangles of the mesh already available.
This option is usually used when a trianulation is already availble and is represented by the matrices \code{nodes} and \code{triangles}.
However the \code{create.MESH.2D} should be used to produce a complete TRIMESH2D object. In https://www.cs.cmu.edu/~quake/triangle.highorder.html
a picture of the node ordering can be found.}

\item{order}{This can be '1' or '2'. It specifies if the triangular output elements should be represented by a 3 or 6 nodes. They are
respectively used for locally 1st and 2nd order Finite Elements.}

\item{verbosity}{This can be '0', '1' or '2'. It indicates the level of verbosity in triangulation process.}
}
\value{
An object of the class TRIMESH with the following variables:
\item{\code{nodes}}{A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.}
\item{\code{nodesmarkers}}{A #nodes-vector containing '1' and '0' to indicate whether or not the node is a boundary node. This argument is rarely used.}
\item{\code{nodesattributes}}{A #nodes-by-n1 matrix containg some real attributes associated to each point.
These are copied unchanged to the output mesh for points in \code{nodes}. However for new points introducted by triangulation
procedure or further refinements, each new point added to the mesh will have quantities assigned to it by linear interpolation. This option is commonly
used to spread the Boundary Conditions to the new nodes introduced by the triangulation process.}
\item{\code{triangles}}{A #triangles-by-3 or #triangles-by-6 matrix, respectively where a 1st and 2nd order mesh is created. In https://www.cs.cmu.edu/~quake/triangle.highorder.html
a picture of the node ordering can be found.}
\item{\code{segments}}{A #segments-by-2 matrix. Each row contains the indices (starting from zero) of the point where a segments start from and finisces to.
Segments are edges that persist after the triangulation. In the basic usage of the library segments are used to define the boundary
of the domain.}
\item{\code{segmentsmarker}}{A #segments-vector containing '1' and '0' to indicate whether or not the segment is a boundary segment. This argument is rarely used.}
\item{\code{edges}}{A #edges-by-2 matrix. Each row contains the indices (starting from zero) of the point where an edge start from and finisces to.}
\item{\code{edgesmarkers}}{A #edges-vector containing '1' and '0' to indicate whether or not the segment is a boundary edge. This argument is rarely used.}
\item{\code{neighbors}}{A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. '-1' if
one side of the triangle is an edge on the boundary of the mesh.}
\item{\code{holes}}{A #holes-by-2 matrix containg a point internal to each hole of the mesh. These points are used to carve the holes
after the triangulation procedure.}
\item{\code{order}}{This can be '1' or '2'. It specifies if the triangular output elements is represented by a 3 or 6 nodes.}
}
\description{
This function is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). The function can be used
to create a triangulation starting from a list of points, to be used as triangles' vertices, and a list of segments defining the shape. However further options are availabe for more complex meshes. The resulting
triangulation is called Constrained Delaunay, thus is constructed in such a way to preserve the input \code{segments} without splitting them.
}
\examples{
library(FEMr)

data(MeuseData)
data(MeuseBorder)
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
plot(mesh)
}

