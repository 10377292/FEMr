% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mesh.2D.R
\name{create.MESH.2D}
\alias{create.MESH.2D}
\title{Create a triangular mesh}
\usage{
create.MESH.2D(nodes = nodeslist, segments = segmentlist)
}
\arguments{
\item{nodes}{A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.}

\item{nodesmarkers}{A #nodes-vector with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.}

\item{nodesattributes}{A #nodes-by-n1 matrix containg nodes' attributes. 
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed  
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value 
of a Dirichlet boundary conditions at boundary nodes added during the triangulation process.}

\item{segments}{A #segments-by-2 matrix. Each row contains the indices (starting from zero) of the nodes where the segment starts from and ends to.
Segments are edges that are not splitted during the triangulation process. These are for instance used to define the boundaries
of the domain. If this is NULL, the traingulation is computed over the
convex hull of the points specified in \code{nodes}.}

\item{segmentsmarkers}{A #segments-vector ith entries either '1' or '0'. An entry '1' indicates that the corresponding segment is a boundary segment;
an entry '0' indicates that the corresponding segment is not a boundary segment.}

\item{holes}{A #holes-by-2 matrix containg the x and y coordinates of a point internal to each hole of the mesh. These points are used to carve the holes
iin the triangulation, when the domain has holes.}

\item{triangles}{A #triangles-by-3 (when \code{order} = 1) or #triangles-by-6 matrix (when \code{order} = 2).
This option is used when a triangulation is already availble. It specify the triangles giving the indices in \code{nodes} of the triangles' vertices and  the triangle edges midpoints (when \code{nodes} = 2). The triangles' vertices and middle points are ordered as descrcibed 
at  https://www.cs.cmu.edu/~quake/triangle.highorder.html.
In this case the function \code{create.MESH.2D} is used to produce a complete TRIMESH2D object.}

\item{order}{Either '1' or '2'. It specifies wether each mesh triangle should be represented by a 3 nodes (the triangle' vertices) or 6 nodes (the triangle'svertices and midpoints). 
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is \code{order} = 1.}

\item{verbosity}{This can be '0', '1' or '2'. It indicates the level of verbosity in triangulation process.  Default is \code{verbosity} = 0.}
}
\value{
An object of the class TRIMESH2D with the following variables:
\item{\code{nodes}}{A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.}
\item{\code{nodesmarkers}}{A #nodes-vector with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.}
\item{\code{nodesattributes}}{A #nodes-by-n1 matrix containg nodes' attributes. 
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed  
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value 
of a Dirichlet boundary conditions at boundary nodes added during the triangulation process.}
\item{\code{triangles}}{A #triangles-by-3 (when \code{order} = 1) or #triangles-by-6 matrix (when \code{order} = 2).
It specify the triangles giving the indices in \code{nodes} of the triangles' vertices and  the triangle edges midpoints (when \code{nodes} = 2). The triangles' vertices and middle points are ordered as descrcibed 
at  https://www.cs.cmu.edu/~quake/triangle.highorder.html.}
\item{\code{segments}}{A #segments-by-2 matrix. Each row contains the indices (starting from zero) of the nodes where the segment starts from and ends to.
Segments are edges that are not splitted during the triangulation process. }
\item{\code{segmentsmarker}}{A #segments-vector with entries either '1' or '0'. An entry '1' indicates that the corresponding segment is a boundary segment;  
an entry '0' indicates that the corresponding segment is not a boundary segment.}
\item{\code{edges}}{A #edges-by-2 matrix. . Each row contains the indices (starting from zero) of the nodes where the edge starts from and ends to.}
\item{\code{edgesmarkers}}{A #edges-vector with entries either '1' or '0'. An entry '1' indicates that the corresponding edge is a boundary edge;  
an entry '0' indicates that the corresponding edge is not a boundary edge.}
\item{\code{neighbors}}{A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. An entry '-1' indicates that 
one side of the triangle is aboundary edge.}
\item{\code{holes}}{A #holes-by-2 matrix containg a point internal to each hole of the mesh. These points are used to carve the holes
after the triangulation procedure.}
\item{\code{order}}{Either '1' or '2'. It specifies wether each mesh triangle is represented by a 3 nodes (the triangle' vertices) or 6 nodes (the triangle'svertices and midpoints). 
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements.}
}
\description{
This function is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). The function can be used
to create a triangulation starting from a list of points, to be used as triangles' vertices, and a list of segments, that define the domain boundary. The resulting
mesh is a Constrained Delaunay triangulation. This is constructed in a way to preserve segmentes provided in the input \code{segments} without splitting them. This imput can be used to define the boundaries
of the domain. If this is imput is NULL, the traingulation is computed over the
convex hull of the points.
}
\examples{
## Upload the Meuse data and a domain boundary for these data
data(MeuseData)
data(MeuseBorder)
## Create a triangulation on the convex hull of these data, where each data location is a triangle vertex
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], order = 1)
## Plot the mesh
plot(mesh)
## Create a Constrained Delaunay triangulation where each data location is a triangle vertex, with the provided boundary
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
## Plot the mesh
plot(mesh)
}

